<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CareyWong&#39;s backyard</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.whiscc.com/"/>
  <updated>2021-05-11T04:10:01.680Z</updated>
  <id>https://www.whiscc.com/</id>
  
  <author>
    <name>CareyWong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis数据结构及实现</title>
    <link href="https://www.whiscc.com/2019/09/redis-data-structure-implements.html"/>
    <id>https://www.whiscc.com/2019/09/redis-data-structure-implements.html</id>
    <published>2019-09-18T06:15:54.000Z</published>
    <updated>2021-05-11T04:10:01.680Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Redis" scheme="https://www.whiscc.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL锁机制</title>
    <link href="https://www.whiscc.com/2019/09/mysql-lock.html"/>
    <id>https://www.whiscc.com/2019/09/mysql-lock.html</id>
    <published>2019-09-18T06:14:47.000Z</published>
    <updated>2021-05-11T04:10:01.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-乐观锁与悲观锁"><a href="#1-乐观锁与悲观锁" class="headerlink" title="1.乐观锁与悲观锁"></a>1.乐观锁与悲观锁</h1><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>不主动加锁，而是在更新前通过校验来判别数据是否被修改。一般通过数据版本（version）记录机制实现，数据行增加 version 字段，每次更新数据都更新对应 version。当读取数据时，version 字段一同取出，提交更新时对比数据行当前 version 是否与之前一致，如果一致则表明数据可进行更新操作，如不一致则认为数据为过期数据，不予更新。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>认为每次操作都会存在数据冲突，所以每次操作时，都需要主动获取锁才能对数据进行操作。悲观锁由数据库内部实现，调用相关语句即可。</p><h3 id="共享锁与排他锁"><a href="#共享锁与排他锁" class="headerlink" title="共享锁与排他锁"></a>共享锁与排他锁</h3><blockquote><p>共享锁与排他锁都属于悲观锁的范畴，是悲观锁的不同实现。</p></blockquote><ul><li><p>共享锁<br>共享锁，俗称读锁（read lock），是由读取操作创建的锁。所有用户可同时获取共享锁，并发读取数据，但是任何事务都不能对该数据进行修改（即获得排他锁）直至共享锁全部被释放。如果事务对加了读锁的数据进行写操作，很可能造成死锁。</p></li><li><p>排他锁<br>排他锁，俗称写锁（write lock），会阻塞其他所有排他锁与共享锁。某一事务对一行数据加上排他锁，则其他事务不能对该行进行读写操作，在此事务结束前，其他事务不能堆该行加任何锁。</p></li></ul><h1 id="2-行锁与表锁"><a href="#2-行锁与表锁" class="headerlink" title="2.行锁与表锁"></a>2.行锁与表锁</h1><h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h2><p>Innodb 基于索引实现行锁，实质上是针对索引加锁而不是针对数据记录加锁，在加锁期间若索引失效，行锁会升级成表锁。</p><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><p>Innodb 与 MyISAM 均支持表锁，Innodb 在不通过索引检索数据时，会使用表锁。</p><h1 id="3-MVCC（Multi-Version-Concurrency-Control：多版本并发控制）"><a href="#3-MVCC（Multi-Version-Concurrency-Control：多版本并发控制）" class="headerlink" title="3.MVCC（Multi-Version Concurrency Control：多版本并发控制）"></a>3.MVCC（Multi-Version Concurrency Control：多版本并发控制）</h1><p>MVCC，即同一份数据临时保留多版本的一种方式，进而实现并发控制。在MySQL中建表时，每个表都会有三列隐藏记录，跟MVCC相关的有：数据行的版本号(DB_TRX_ID)、删除版本号 (DB_ROLL_PT)。</p><h2 id="MVCC-insert"><a href="#MVCC-insert" class="headerlink" title="MVCC-insert"></a>MVCC-insert</h2><p>执行插入操作时，将全局事务ID写入 DB_TRX_ID。</p><h2 id="MVCC-delete"><a href="#MVCC-delete" class="headerlink" title="MVCC-delete"></a>MVCC-delete</h2><p>执行删除操作时，数据并没有被真正删除，而是全局事务ID记录至 DB_ROLL_PT。</p><h2 id="MVCC-update"><a href="#MVCC-update" class="headerlink" title="MVCC-update"></a>MVCC-update</h2><p>复制当前记录行A的副本到一条新的记录B，B中 DB_TRX_ID 置为 A 的 DB_ROLL_PT。</p><h2 id="MVCC-select"><a href="#MVCC-select" class="headerlink" title="MVCC-select"></a>MVCC-select</h2><p>查找数据行版本号小于当前事务版本号、删除版本号要么为 NULL 要么大于当前事务版本号的数据行记录，确保查询出来的数据行记录在事务开启之前没有被删除。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-乐观锁与悲观锁&quot;&gt;&lt;a href=&quot;#1-乐观锁与悲观锁&quot; class=&quot;headerlink&quot; title=&quot;1.乐观锁与悲观锁&quot;&gt;&lt;/a&gt;1.乐观锁与悲观锁&lt;/h1&gt;&lt;h2 id=&quot;乐观锁&quot;&gt;&lt;a href=&quot;#乐观锁&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://www.whiscc.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Laravel-Permission 使用小记</title>
    <link href="https://www.whiscc.com/2019/07/laravel-permission-nesting.html"/>
    <id>https://www.whiscc.com/2019/07/laravel-permission-nesting.html</id>
    <published>2019-07-21T07:07:05.000Z</published>
    <updated>2021-05-11T04:10:01.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TODO&quot;&gt;&lt;a href=&quot;#TODO&quot; class=&quot;headerlink&quot; title=&quot;TODO&quot;&gt;&lt;/a&gt;TODO&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="php" scheme="https://www.whiscc.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>PHP Composer 国内全量镜像源整理</title>
    <link href="https://www.whiscc.com/2019/07/composer-mirrors.html"/>
    <id>https://www.whiscc.com/2019/07/composer-mirrors.html</id>
    <published>2019-07-15T03:04:45.000Z</published>
    <updated>2021-05-11T04:10:01.680Z</updated>
    
    <content type="html"><![CDATA[<p>近日，各大云服务厂商逐渐公布了自己的 PHP Composer 全量镜像，整理以下『全量镜像』供大家选择。</p><h1 id="PHP-Composer-安装"><a href="#PHP-Composer-安装" class="headerlink" title="PHP Composer 安装"></a>PHP Composer 安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');"</span><br><span class="line">php composer-setup.php</span><br><span class="line">php -r "unlink('composer-setup.php');"</span><br><span class="line">mv composer.phar /usr/local/bin/composer</span><br></pre></td></tr></table></figure><h1 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a><a href="https://developer.aliyun.com/composer" target="_blank" rel="noopener">阿里云</a></h1><p>自用稳定性很好，个人目前选择。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/</span><br></pre></td></tr></table></figure><h1 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a><a href="https://mirrors.cloud.tencent.com/composer/" target="_blank" rel="noopener">腾讯云</a></h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g repos.packagist composer https://mirrors.cloud.tencent.com/composer/</span><br></pre></td></tr></table></figure><h1 id="phpcomposer"><a href="#phpcomposer" class="headerlink" title="phpcomposer"></a><a href="https://pkg.phpcomposer.com/" target="_blank" rel="noopener">phpcomposer</a></h1><p>国内很早开放的免费镜像服务，其他服务商跟进之前的首选。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g repo.packagist composer https://packagist.phpcomposer.com</span><br></pre></td></tr></table></figure><h1 id="Laravel-China-镜像"><a href="#Laravel-China-镜像" class="headerlink" title="Laravel China 镜像"></a><del><a href="https://packagist.laravel-china.org" target="_blank" rel="noopener">Laravel China 镜像</a></del></h1><p>完成历史使命，将于 2019-09-01 之后终止服务，感谢 Laravel-China 对开源事业的贡献！</p><h1 id="华为云"><a href="#华为云" class="headerlink" title="华为云"></a><a href="https://mirrors.huaweicloud.com/" target="_blank" rel="noopener">华为云</a></h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g repo.packagist composer https://mirrors.huaweicloud.com/repository/php/</span><br></pre></td></tr></table></figure><h1 id="安畅网络"><a href="#安畅网络" class="headerlink" title="安畅网络"></a><a href="https://php.cnpkg.org/" target="_blank" rel="noopener">安畅网络</a></h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g repos.packagist composer https://php.cnpkg.org</span><br></pre></td></tr></table></figure><h1 id="关闭全局配置"><a href="#关闭全局配置" class="headerlink" title="关闭全局配置"></a>关闭全局配置</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer config -g --unset repos.packagist</span><br></pre></td></tr></table></figure><h1 id="多线程下载"><a href="#多线程下载" class="headerlink" title="多线程下载"></a>多线程下载</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">composer global require hirak/prestissimo</span><br><span class="line">composer clearcache</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;近日，各大云服务厂商逐渐公布了自己的 PHP Composer 全量镜像，整理以下『全量镜像』供大家选择。&lt;/p&gt;
&lt;h1 id=&quot;PHP-Composer-安装&quot;&gt;&lt;a href=&quot;#PHP-Composer-安装&quot; class=&quot;headerlink&quot; title=&quot;P
      
    
    </summary>
    
    
      <category term="php" scheme="https://www.whiscc.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Redis 集群之 Redis-Cluster</title>
    <link href="https://www.whiscc.com/2019/07/redis-cluster-introduction.html"/>
    <id>https://www.whiscc.com/2019/07/redis-cluster-introduction.html</id>
    <published>2019-07-13T06:27:10.000Z</published>
    <updated>2021-05-11T04:10:01.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="业务背景"><a href="#业务背景" class="headerlink" title="业务背景"></a>业务背景</h1><p>&emsp;&emsp;组内大约是去年引入 redis 作为缓存服务，由于当时经验的欠缺，只是局限于 key-value 存储极少部分配置，因此只是在某台机器上起了一个 docker，一台 redis 服务供几个系统调用。<br>&emsp;&emsp;由于业务需求、组内成员缓存方面知识加深以及我这个『始作俑者』对缓存的好感，缓存使用频度日益增长。虽然性能上暂时还未出现瓶颈，在新系统上线后，基于 redis 消息队列的加入、各类非关系型数据的存储逐渐增加，加上缓存的手动刷新机制的不完善，redis 业务分离与灾备刻不容缓。</p><hr><h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h2 id="Redis-Sentinel"><a href="#Redis-Sentinel" class="headerlink" title="Redis-Sentinel"></a>Redis-Sentinel</h2><p>高可用集群，各节点同时只有一个 master，各实例数据保持一致。</p><p><img src="http://pugk0v3np.bkt.clouddn.com/redis-sentinel.png" alt="avatar"></p><h2 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis-Cluster"></a>Redis-Cluster</h2><p>分布式集群，同时有多个 master，数据分片部署在各个 master 上（不一定均匀），也是本次实践的目标。</p><p><img src="http://pugk0v3np.bkt.clouddn.com/redis-cluster-model.png" alt="avatar"></p><ul><li>特点<ul><li>无中心节点，客户端与 redis节点直连，不需要中间代理层。</li><li>数据可以被分片存储，集群数据加起来就是全量数据。</li><li>可以通过任意一个节点，读写不属于本节点的数据。</li><li>管理方便，后续可自行增加或删除节点。</li></ul></li><li>结构特点<ul><li>所有的 redis 节点彼此互联(PING-PONG机制)，内部使用二进制协议优化传输速度和带宽。</li><li>节点的 fail 是通过集群中超过半数的节点检测失效时才生效。</li><li>Redis 集群预分好 16384 个哈希槽(hash slot)，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384 的值，决定将一个 key 放到哪个哈希槽中。<br><img src="http://pugk0v3np.bkt.clouddn.com/redis-cluster.png" alt="avatar"></li></ul></li><li>由于采用无中心结构，每个节点保存数据和整个集群状态，每个节点都和其他所有节点连接。</li><li>由于分片存储，当集群中一个节点故障时，会损失该节点数据。为了实现高可用，需要对每个节点各添加一个从节点，形成主从同步。</li><li>为了保证数据的高可用性，加入了主从模式，一个 master 对应一个或多个 slave ，master 提供数据存取，slave 则是从 master 拉取数据备份。当 master 挂了，就会从 slave 节点中选取一个来充当 master，从而保证集群不会挂掉。</li></ul><hr><h1 id="Just-do-it"><a href="#Just-do-it" class="headerlink" title="Just do it !"></a>Just do it !</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><p>本次 Redis-Cluster 在 Ubuntu 下，基于 Docker + Docker-Compose + 官方 Redis 镜像实现，后续可能加入 ES &amp; Kibana &amp; Zabbix 做数据分析与监控。</p><table><thead><tr><th>Program</th><th>Version</th></tr></thead><tbody><tr><td>Ubuntu</td><td>16.04</td></tr><tr><td>Docker</td><td>18.09.1, build 4c52b90</td></tr><tr><td>Docker-Compose</td><td>1.17.1, build 6d101fb</td></tr><tr><td>Redis</td><td>5.0.5</td></tr></tbody></table><h2 id="开工"><a href="#开工" class="headerlink" title="开工"></a>开工</h2><blockquote><p><a href="https://github.com/CareyWang/gaia/tree/master/redis" target="_blank" rel="noopener">Github</a> 可以找到下面 docker-compose.yml 以及其他配置。学习之路才刚刚开始，欢迎大佬们指正错误。</p></blockquote><ul><li>建立集群</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">cd</span> /var/www/http/docker/redis/cluster</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于 Redis-Cluster fail 机制的要求，需要奇数台服务，即最少开启三台 master，也就是三主三从，六个服务</span></span><br><span class="line">&gt; docker-compose up -d</span><br><span class="line">Creating network <span class="string">"redis_cluster-net"</span> with the default driver</span><br><span class="line">Creating redis-node-6 ... <span class="keyword">done</span></span><br><span class="line">Creating redis-node-3 ... <span class="keyword">done</span></span><br><span class="line">Creating redis-node-4 ... <span class="keyword">done</span></span><br><span class="line">Creating redis-node-2 ... <span class="keyword">done</span></span><br><span class="line">Creating redis-node-5 ... <span class="keyword">done</span></span><br><span class="line">Creating redis-node-1 ... <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">&gt; docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                               NAMES</span><br><span class="line">a4c9fc13b94b        redis:5.0.5         <span class="string">"docker-entrypoint.s…"</span>   34 minutes ago      Up 34 minutes       0.0.0.0:46378-&gt;6379/tcp, 0.0.0.0:56378-&gt;56379/tcp   redis-node-2</span><br><span class="line">ae35b2c82512        redis:5.0.5         <span class="string">"docker-entrypoint.s…"</span>   34 minutes ago      Up 34 minutes       0.0.0.0:46377-&gt;6379/tcp, 0.0.0.0:56377-&gt;56379/tcp   redis-node-3</span><br><span class="line">b3d3dd2c5c18        redis:5.0.5         <span class="string">"docker-entrypoint.s…"</span>   34 minutes ago      Up 34 minutes       0.0.0.0:46376-&gt;6379/tcp, 0.0.0.0:56376-&gt;56379/tcp   redis-node-4</span><br><span class="line">fbc91dfe0274        redis:5.0.5         <span class="string">"docker-entrypoint.s…"</span>   34 minutes ago      Up 34 minutes       0.0.0.0:56379-&gt;56379/tcp, 0.0.0.0:46379-&gt;6379/tcp   redis-node-1</span><br><span class="line">ddd307094e91        redis:5.0.5         <span class="string">"docker-entrypoint.s…"</span>   34 minutes ago      Up 34 minutes       0.0.0.0:46375-&gt;6379/tcp, 0.0.0.0:56375-&gt;56379/tcp   redis-node-5</span><br><span class="line">125ba63e2d62        redis:5.0.5         <span class="string">"docker-entrypoint.s…"</span>   34 minutes ago      Up 34 minutes       0.0.0.0:46374-&gt;6379/tcp, 0.0.0.0:56374-&gt;56379/tcp   redis-node-6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随意进入刚才创建的某个 docker </span></span><br><span class="line">&gt; docker <span class="built_in">exec</span> -it redis-node-1 bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立 redis 集群，--cluster-replicas 表明每台实例有一台 slave </span></span><br><span class="line">&gt; redis-cli --cluster create 172.10.15.11:6379 172.10.15.12:6379 172.10.15.13:6379 172.10.15.14:6379 172.10.15.15:6379 172.10.15.16:6379 --cluster-replicas 1</span><br><span class="line">&gt;&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 172.10.15.15:6379 to 172.10.15.11:6379</span><br><span class="line">Adding replica 172.10.15.16:6379 to 172.10.15.12:6379</span><br><span class="line">Adding replica 172.10.15.14:6379 to 172.10.15.13:6379</span><br><span class="line">M: 5f5d5d64f02f5b7b9df21c9e58aa5ea860749a15 172.10.15.11:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: 61d23b6fe5f5a7d2ff97cc9d33c192c6fc8dcd58 172.10.15.12:6379</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 011d9587f7d2b11890bce67ea70f614fd726a881 172.10.15.13:6379</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: 472b162a3dd50ee8f805780be576cd21a292d3e2 172.10.15.14:6379</span><br><span class="line">   replicates 011d9587f7d2b11890bce67ea70f614fd726a881</span><br><span class="line">S: 81d44f046103351041bf0dd8cae8643269029354 172.10.15.15:6379</span><br><span class="line">   replicates 5f5d5d64f02f5b7b9df21c9e58aa5ea860749a15</span><br><span class="line">S: ef57b7c1b1378ad43fe396c5780a653a6989594f 172.10.15.16:6379</span><br><span class="line">   replicates 61d23b6fe5f5a7d2ff97cc9d33c192c6fc8dcd58</span><br><span class="line">Can I <span class="built_in">set</span> the above configuration? (<span class="built_in">type</span> <span class="string">'yes'</span> to accept): yes</span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting <span class="keyword">for</span> the cluster to join</span><br><span class="line">.....</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 172.10.15.11:6379)</span><br><span class="line">M: 5f5d5d64f02f5b7b9df21c9e58aa5ea860749a15 172.10.15.11:6379</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: ef57b7c1b1378ad43fe396c5780a653a6989594f 172.10.15.16:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 61d23b6fe5f5a7d2ff97cc9d33c192c6fc8dcd58</span><br><span class="line">S: 81d44f046103351041bf0dd8cae8643269029354 172.10.15.15:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 5f5d5d64f02f5b7b9df21c9e58aa5ea860749a15</span><br><span class="line">M: 011d9587f7d2b11890bce67ea70f614fd726a881 172.10.15.13:6379</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 472b162a3dd50ee8f805780be576cd21a292d3e2 172.10.15.14:6379</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 011d9587f7d2b11890bce67ea70f614fd726a881</span><br><span class="line">M: 61d23b6fe5f5a7d2ff97cc9d33c192c6fc8dcd58 172.10.15.12:6379</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure><h2 id="集群测试"><a href="#集群测试" class="headerlink" title="集群测试"></a>集群测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -c 表示连接的 Redis-Cluster 集群，这里必须加上，否则各台服务之间通信会有问题</span></span><br><span class="line">&gt; redis-cli -h 172.10.15.11 -p 6379 -c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看集群信息</span></span><br><span class="line">172.10.15.11:6379&gt; cluster info </span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:6</span><br><span class="line">cluster_my_epoch:3</span><br><span class="line">cluster_stats_messages_ping_sent:343</span><br><span class="line">cluster_stats_messages_pong_sent:371</span><br><span class="line">cluster_stats_messages_meet_sent:1</span><br><span class="line">cluster_stats_messages_sent:715</span><br><span class="line">cluster_stats_messages_ping_received:367</span><br><span class="line">cluster_stats_messages_pong_received:344</span><br><span class="line">cluster_stats_messages_meet_received:4</span><br><span class="line">cluster_stats_messages_received:715</span><br><span class="line"></span><br><span class="line">172.10.15.11:6379&gt; <span class="built_in">set</span> user admin</span><br><span class="line">-&gt; Redirected to slot [5474] located at 172.10.15.12:6379</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h1 id="业务使用"><a href="#业务使用" class="headerlink" title="业务使用"></a>业务使用</h1><blockquote><p>由于目前作为一名 phper ，目前没有涉猎其他语言的扩展研究，这里只以 Predis 为例。原理都是相近，应该都有各自成熟的解决方案。</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里 server 可以填写上面六台中任意一台的 ip（当然不嫌麻烦也可以都填上），集群内部会自动重定向</span></span><br><span class="line">$servers = [</span><br><span class="line">    <span class="string">'tcp://172.10.15.11:6379'</span>,</span><br><span class="line">];</span><br><span class="line">$options = [<span class="string">'cluster'</span> =&gt; <span class="string">'redis'</span>];</span><br><span class="line"></span><br><span class="line">$client = <span class="keyword">new</span> Predis\Client($servers, $options);</span><br><span class="line">$client-&gt;set(<span class="string">'user'</span>, <span class="string">'admin'</span>);</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这里只是很简单地介绍了个人 Redis-Cluster 服务的搭建的经历，对于内部例如主从复制机制、通信机制等更深入的知识，个人也在学习之中。有遗漏之处，还望海涵。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;业务背景&quot;&gt;&lt;a href=&quot;#业务背景&quot; class=&quot;headerlink&quot; title=&quot;业务背景&quot;&gt;&lt;/a&gt;业务背景&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;组内大约是去年引入 redis 作为缓存服务，由于当时经验的欠缺，只是局限于 key-value 存
      
    
    </summary>
    
    
      <category term="Redis" scheme="https://www.whiscc.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 事务嵌套解决方案小结</title>
    <link href="https://www.whiscc.com/2019/07/mysql-transaction-nesting.html"/>
    <id>https://www.whiscc.com/2019/07/mysql-transaction-nesting.html</id>
    <published>2019-07-12T06:27:34.000Z</published>
    <updated>2021-05-11T04:10:01.680Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;MySQL 事务机制被广泛用于处理操作量大、复杂度高的数据，日常业务中也很常见。在默认的 MySQL 配置下，事务默认是自动提交的，因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUTOCOMMIT=0，用来禁止使用当前会话的自动提交。</p><hr><p>&emsp;&emsp;MySQL <a href="http://dev.mysql.com/doc/refman/5.0/en/implicit-commit.html" target="_blank" rel="noopener">官方文档</a>中，明确的说明了不支持嵌套事务嵌套。但是在我们开发一个复杂的系统时，由于思维的局限性，函数之间相互调用中，事务的嵌套很难彻底避免。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT `value` FROM tmptable.transaction_test;</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| value |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| 1     |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO tmptable.transaction_test (`value`) VALUES ( '2' );</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; START TRANSACTION;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO tmptable.transaction_test (`value`) VALUES ( '3' );</span><br><span class="line">Query OK, 1 row affected (0.02 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; COMMIT;</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; ROLLBACK;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT `value` FROM tmptable.transaction_test;</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| value |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">| 1     |</span><br><span class="line">| 2     |</span><br><span class="line">| 3     |</span><br><span class="line">+<span class="comment">-------+</span></span><br><span class="line">3 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段 SQL 的执行结果，按常规思维理解应该是 commit 操作提交了 2 的insert，rollback 操作回滚了 3 的 insert，最终结果应该是 1, 2。然而事实上，看上去 MySQL 只是执行了其中的 commit 操作，后续的 rollback 并没有带来数据上的改变。当 SQL 解释器遇到 START TRANSACTION 时候会触发 commit，也就是说 2 的 insert 操作在第二次开启事务时，已经被隐式地提交了。</p><h1 id="ORM-中常见的解决思路"><a href="#ORM-中常见的解决思路" class="headerlink" title="ORM 中常见的解决思路"></a>ORM 中常见的解决思路</h1><ul><li><a href="https://www.doctrine-project.org/" target="_blank" rel="noopener">Doctrine</a><br>TODO</li><li>Laravel<br>TODO</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;MySQL 事务机制被广泛用于处理操作量大、复杂度高的数据，日常业务中也很常见。在默认的 MySQL 配置下，事务默认是自动提交的，因此要显式地开启一个事务务须使用命令 BEGIN 或 START TRANSACTION，或者执行命令 SET AUT
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://www.whiscc.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 主从原理、读写分离及实现</title>
    <link href="https://www.whiscc.com/2019/07/mysql-master-slave-introduction.html"/>
    <id>https://www.whiscc.com/2019/07/mysql-master-slave-introduction.html</id>
    <published>2019-07-10T06:28:02.000Z</published>
    <updated>2021-05-11T04:10:01.680Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;MySQL最重要的功能之一。指一台服务器充当主数据库服务器，另一台或多台服务器充当从数据库服务器，主服务器中的数据自动复制到从服务器之中。</p><h1 id="主从作用"><a href="#主从作用" class="headerlink" title="主从作用"></a>主从作用</h1><ul><li>数据备份。</li><li>高可用性（负载均衡，容灾）。</li><li>在MySQL主从复制架构中，读操作可以在所有的服务器上面进行，而写操作只能在主服务器上面进行，给读操作提供了扩展。</li></ul><h1 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h1><p>方式：基于日志与基于GTID全局事务标志符，这里主要介绍第一种。</p><ul><li>基础是主服务器对数据库修改记录二进制日志(以下简称 binlog)，从服务器通过主服务器的二进制日志自动执行更新。</li><li>主服务器上面的任何修改都会保存在 binlog (mysql- bin.xxxxxx)里面。</li><li>从服务器上面启动一个 I/O 线程（实际上就是一个主服务器的客户端进程），连接到主服务器读取指定 binlog 指定位置之后信息，然后返回给 slave 的 I/O 线程。返回的信息中除了 binlog 内容外，还有本次返回日志内容后在 master 服务器端的新的 binlog 文件名称以及在 binlog 中的下一个指定更新位置。</li><li>当 slave 服务器的 I/O 线程获取到来自 master 服务器上 I/O 线程发送日志内容以及日志文件以及位置点后，将 binlog 内容一次写入到 slave 端自身的 relaylog (中继日志)文件(mysql-relay-bin.xxxxxx)的末尾，并将新的 binlog 文件名和位置记录到 master-info 文件中，以便下次读取 master 端新 binlog 日志时，能够告诉 master 服务器需要从新 binlog 日志的哪个文件哪个位置开始请求新的 binlog 内容。</li><li>slave 服务器的 SQL 线程会实时的检测本地 relaylog 中新增加的日志内容，然后及时的把 relaylog 文件中的内容解析成在 master 端曾经执行的 SQL 语句的内容，并在自身按语句的顺序执行应用这些 SQL 语句，应用完毕后清理用过的日志。</li><li>当复制状态正常的情况下，在 master 和 slave 执行了同样的SQL语句，主从的数据是完全一样的。</li><li>在老版本的 MySQL 主从复制中 slave 端并不是两个进程完成的，而是由一个进程完成。复制 binlog 和解析日志并在自身执行的过程成为一个串行的过程，性能受到了一定的限制，异步复制的延迟也会比较长。</li></ul><h1 id="主从复制模式"><a href="#主从复制模式" class="headerlink" title="主从复制模式"></a>主从复制模式</h1><ul><li>异步模式<ul><li>MySQL 默认的复制是异步模式，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已接收并处理。</li></ul></li><li>同步模式<ul><li>主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。</li><li>由于需要等待所有从库执行完事务，性能会受到极大影响。</li></ul></li><li>半同步模式<ul><li>主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到 relaylog 中才返回给客户端。</li><li>相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟。</li></ul></li></ul><h1 id="主从复制类型"><a href="#主从复制类型" class="headerlink" title="主从复制类型"></a>主从复制类型</h1><ul><li>基于语句的复制(STATEMENT)<ul><li>MySQL 默认使用基于语句的复制。</li><li>主服务器上面执行的语句在从服务器上面再执行一遍。</li><li>存在的问题：时间上可能不完全同步造成偏差，执行语句的用户也可能是不同一个用户。</li><li>使用 MySQL 的功能相对少（存储过程、触发器、函数），选择基于语句的复制。</li></ul></li><li>混合类型的复制(MIXED)<ul><li>当基于语句的复制会引发问题的时候就会使用基于行的复制，MySQL会自动进行选择。</li><li>使用MySQL的特殊功能（存储过程、触发器、函数），选择混合类型的复制。</li></ul></li><li>基于行的复制(ROW)</li><li>把主服务器上面更新后的内容直接复制过去，而不关心到底改变该内容是由哪条语句引发的。</li><li>存在的问题：表t有10000行数据，某字段+100，基于行的复制需制10000行的内容，开销较大；基于语句的复制只需要一条语句就可以了。</li><li>使用 MySQL 的特殊功能（存储过程、触发器、函数）又希望数据最大化一致，选择基于行的复制。</li></ul><h1 id="MySQL的复制过滤-Replication-Filters"><a href="#MySQL的复制过滤-Replication-Filters" class="headerlink" title="MySQL的复制过滤(Replication Filters)"></a>MySQL的复制过滤(Replication Filters)</h1><p>主要用途：复制特定的数据表或库到从库</p><ul><li>在 master 上过滤二进制日志中的事件。</li><li>在 slave 上过滤中继日志中的事件。</li></ul><h1 id="主从复制优化方案"><a href="#主从复制优化方案" class="headerlink" title="主从复制优化方案"></a>主从复制优化方案</h1><ul><li>若一主多从，master 既需要负责写操作，又要负责为几个从库提供二进制日志。此时可以稍做调整，将 binlog 只给某一 slave，该 slave 再开启 binlog 并将自己的 binlog 再分发给其他从库。或者是干脆这个从库不记录数据，只负责转发 binlog。</li><li>And so on …</li></ul><h1 id="主从数据一致性检测"><a href="#主从数据一致性检测" class="headerlink" title="主从数据一致性检测"></a>主从数据一致性检测</h1><p>TODO…</p><h1 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h1><ul><li>优点<ul><li>高可用</li><li>负载均衡</li><li>业务模块化（索引 | 存储引擎）</li><li>数据备份</li><li>便于拓展</li></ul></li><li>存在的问题<ul><li>成本增加（增加机器 | 额外开启 binlog 占用存储空间）</li><li>slave 数据延迟</li><li>写入更慢</li></ul></li><li>主流实现方式<ul><li>程序代码内部实现</li><li>中间代理层实现</li></ul></li></ul><h1 id="数据库中间件"><a href="#数据库中间件" class="headerlink" title="数据库中间件"></a>数据库中间件</h1><ul><li>读写分离方案</li><li>负载均衡的简单实现</li><li>分库分表主流实现思路<ul><li>业务起步初始，为了加快应用上线和快速迭代，很多应用都采用集中式的架构。随着业务系统的扩大，系统变得越来越复杂，通过硬件提高系统性能的方式带来的成本也越来越高。</li></ul></li></ul><h1 id="Just-do-it"><a href="#Just-do-it" class="headerlink" title="Just do it !"></a>Just do it !</h1><h2 id="配置主库"><a href="#配置主库" class="headerlink" title="配置主库"></a>配置主库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id   = 1</span><br><span class="line">log_bin     = /var/log/mysql/mysql-bin.log</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> binlog_format = "STATEMENT"</span><br><span class="line"><span class="meta">#</span> binlog_format = "ROW"</span><br><span class="line"><span class="meta">#</span> binlog_format = "MIXED"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 被忽略的数据库</span><br><span class="line"><span class="meta">#</span> binlog-ignore-db=mysql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 需要同步的数据库，不配置则表示同步所有</span><br><span class="line"><span class="meta">#</span> binlog-do-db=DB-XXX</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看binlog模式</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'%binlog_format%'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看binlog</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">MASTER</span> <span class="keyword">STATUS</span>;</span><br></pre></td></tr></table></figure><h2 id="配置从库"><a href="#配置从库" class="headerlink" title="配置从库"></a>配置从库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id = 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 忽略的数据库</span><br><span class="line"><span class="meta">#</span> replicate-ignore-db=mysql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 需要同步的数据库，不配置则表示同步所有</span><br><span class="line"><span class="meta">#</span> replicate-do-db=DB-XXX</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">STOP</span> <span class="keyword">SLAVE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接master</span></span><br><span class="line"><span class="comment"># 其中repl是master上拥有 Replication Slave 权限的账户</span></span><br><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> </span><br><span class="line">master_host = <span class="string">'127.0.0.1'</span>,</span><br><span class="line">master_port = <span class="number">3306</span>,</span><br><span class="line">master_user = <span class="string">'repl'</span>,</span><br><span class="line">master_password = <span class="string">'passw0rd'</span></span><br><span class="line">master_log_file = <span class="string">'master-bin.000001'</span>,</span><br><span class="line">master_log_pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">SLAVE</span>;</span><br></pre></td></tr></table></figure><h2 id="查看binlog文件"><a href="#查看binlog文件" class="headerlink" title="查看binlog文件"></a>查看binlog文件</h2><ul><li>binlog文件一般为mysql-bin.+序号</li><li>重启mysql或运行flush logs,都会生成一个新的二进制日志，并且序号加1</li><li>索引文件mysql-bin.index</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="built_in">BINARY</span> <span class="keyword">LOGS</span>;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog --base64-output="decode-rows" mysql-bin.000001</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;MySQL最重要的功能之一。指一台服务器充当主数据库服务器，另一台或多台服务器充当从数据库服务器，主服务器中的数据自动复制到从服务器之中。&lt;/p&gt;
&lt;h1 id=&quot;主从作用&quot;&gt;&lt;a href=&quot;#主从作用&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="MySQL" scheme="https://www.whiscc.com/tags/MySQL/"/>
    
  </entry>
  
</feed>
